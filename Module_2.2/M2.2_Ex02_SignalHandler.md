# Ex02: Advanced Signal Handler

## Concepts couverts
- 2.2.10.e: SIGINT (Interrupt Ctrl-C)
- 2.2.11.h: SA_SIGINFO (use sa_sigaction)
- 2.2.11.j: SA_RESETHAND (reset to default after)
- 2.2.11.k: SIG_IGN (ignore signal)
- 2.2.11.l: SIG_DFL (default action)
- 2.2.12.g: sigismember() (test membership)
- 2.2.12.m: sigpending() (get pending set)
- 2.2.13.a: kill() (send signal to process)
- 2.2.13.c: kill(0, sig) (to process group)
- 2.2.13.d: kill(-1, sig) (to all with permission)
- 2.2.13.f: killpg() (send to process group)
- 2.2.13.i: tgkill() (send to thread)
- 2.2.14.a: RT signal range (SIGRTMIN to SIGRTMAX)
- 2.2.14.b: RT Queuing (not lost)
- 2.2.14.g: SA_SIGINFO (receive siginfo_t)

## Description
Implementer un framework de gestion de signaux avance en Rust 2024 qui supporte les signaux temps-reel, le queuing, et l'envoi de signaux avec donnees. Inclure un multiplexeur de signaux pour gerer plusieurs handlers de maniere organisee.

## Objectifs pedagogiques
1. Comprendre les differences entre signaux standard et temps-reel
2. Maitriser sigaction avec SA_SIGINFO pour recevoir des metadonnees
3. Implementer le queuing de signaux temps-reel
4. Gerer les masques de signaux et les signaux pending
5. Envoyer des signaux avec donnees via sigqueue

## Structure (Rust 2024)

```rust
// src/lib.rs

use std::collections::HashMap;
use std::sync::atomic::{AtomicBool, AtomicI32, Ordering};
use std::sync::{Arc, Mutex, RwLock};
use std::os::raw::{c_int, c_void};
use std::mem::MaybeUninit;

// ============================================
// TYPES FFI
// ============================================

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub struct SigInfo {
    pub si_signo: c_int,      // Signal number
    pub si_errno: c_int,      // Error number
    pub si_code: c_int,       // Signal code
    pub si_pid: i32,          // Sending process ID
    pub si_uid: u32,          // Sending user ID
    pub si_status: c_int,     // Exit value or signal
    pub si_addr: *mut c_void, // Memory location for SIGSEGV
    pub si_value: SigVal,     // Signal value (for RT signals)
    // ... autres champs platform-specific
}

#[repr(C)]
#[derive(Clone, Copy, Debug)]
pub union SigVal {
    pub sival_int: c_int,
    pub sival_ptr: *mut c_void,
}

// ============================================
// SIGNAUX STANDARD ET RT
// ============================================

/// Signaux standard
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[repr(i32)]
pub enum Signal {
    SIGHUP = 1,
    SIGINT = 2,
    SIGQUIT = 3,
    SIGILL = 4,
    SIGTRAP = 5,
    SIGABRT = 6,
    SIGBUS = 7,
    SIGFPE = 8,
    SIGKILL = 9,
    SIGUSR1 = 10,
    SIGSEGV = 11,
    SIGUSR2 = 12,
    SIGPIPE = 13,
    SIGALRM = 14,
    SIGTERM = 15,
    SIGCHLD = 17,
    SIGCONT = 18,
    SIGSTOP = 19,
    SIGTSTP = 20,
    SIGTTIN = 21,
    SIGTTOU = 22,
    SIGURG = 23,
    SIGXCPU = 24,
    SIGXFSZ = 25,
    SIGVTALRM = 26,
    SIGPROF = 27,
    SIGWINCH = 28,
    SIGIO = 29,
    SIGPWR = 30,
    SIGSYS = 31,
}

impl Signal {
    pub fn from_raw(sig: c_int) -> Option<Self> {
        match sig {
            1 => Some(Signal::SIGHUP),
            2 => Some(Signal::SIGINT),
            // ... etc
            15 => Some(Signal::SIGTERM),
            _ => None,
        }
    }

    pub fn as_raw(&self) -> c_int {
        *self as c_int
    }

    /// Est-ce un signal temps-reel?
    pub fn is_realtime(sig: c_int) -> bool {
        sig >= Self::sigrtmin() && sig <= Self::sigrtmax()
    }

    /// Premier signal RT
    pub fn sigrtmin() -> c_int {
        unsafe { libc::SIGRTMIN() }
    }

    /// Dernier signal RT
    pub fn sigrtmax() -> c_int {
        unsafe { libc::SIGRTMAX() }
    }
}

// ============================================
// SIGNAL SET
// ============================================

/// Wrapper autour de sigset_t
pub struct SignalSet {
    set: libc::sigset_t,
}

impl SignalSet {
    /// Creer un set vide
    pub fn empty() -> Self {
        let mut set = MaybeUninit::uninit();
        unsafe {
            libc::sigemptyset(set.as_mut_ptr());
            Self { set: set.assume_init() }
        }
    }

    /// Creer un set avec tous les signaux
    pub fn full() -> Self {
        let mut set = MaybeUninit::uninit();
        unsafe {
            libc::sigfillset(set.as_mut_ptr());
            Self { set: set.assume_init() }
        }
    }

    /// Ajouter un signal
    pub fn add(&mut self, sig: c_int) -> &mut Self {
        unsafe { libc::sigaddset(&mut self.set, sig); }
        self
    }

    /// Retirer un signal
    pub fn remove(&mut self, sig: c_int) -> &mut Self {
        unsafe { libc::sigdelset(&mut self.set, sig); }
        self
    }

    /// Verifier si un signal est dans le set
    pub fn contains(&self, sig: c_int) -> bool {
        unsafe { libc::sigismember(&self.set, sig) == 1 }
    }

    /// Obtenir les signaux pending
    pub fn pending() -> Result<Self, std::io::Error> {
        let mut set = Self::empty();
        let ret = unsafe { libc::sigpending(&mut set.set) };
        if ret == 0 {
            Ok(set)
        } else {
            Err(std::io::Error::last_os_error())
        }
    }

    /// Bloquer les signaux de ce set
    pub fn block(&self) -> Result<Self, std::io::Error> {
        let mut old_set = Self::empty();
        let ret = unsafe {
            libc::sigprocmask(libc::SIG_BLOCK, &self.set, &mut old_set.set)
        };
        if ret == 0 {
            Ok(old_set)
        } else {
            Err(std::io::Error::last_os_error())
        }
    }

    /// Debloquer les signaux de ce set
    pub fn unblock(&self) -> Result<Self, std::io::Error> {
        let mut old_set = Self::empty();
        let ret = unsafe {
            libc::sigprocmask(libc::SIG_UNBLOCK, &self.set, &mut old_set.set)
        };
        if ret == 0 {
            Ok(old_set)
        } else {
            Err(std::io::Error::last_os_error())
        }
    }

    /// Remplacer le masque
    pub fn set_mask(&self) -> Result<Self, std::io::Error> {
        let mut old_set = Self::empty();
        let ret = unsafe {
            libc::sigprocmask(libc::SIG_SETMASK, &self.set, &mut old_set.set)
        };
        if ret == 0 {
            Ok(old_set)
        } else {
            Err(std::io::Error::last_os_error())
        }
    }

    pub fn as_ptr(&self) -> *const libc::sigset_t {
        &self.set
    }
}

// ============================================
// SIGNAL HANDLER
// ============================================

/// Action pour un signal
pub enum SignalAction {
    /// Ignorer le signal
    Ignore,
    /// Action par defaut
    Default,
    /// Handler personnalise (simple)
    Handler(fn(c_int)),
    /// Handler avec info (SA_SIGINFO)
    HandlerInfo(fn(c_int, &SigInfo, *mut c_void)),
}

/// Configuration d'un handler
pub struct SignalConfig {
    pub action: SignalAction,
    pub mask: SignalSet,
    pub flags: SignalFlags,
}

bitflags::bitflags! {
    pub struct SignalFlags: c_int {
        const NOCLDSTOP = libc::SA_NOCLDSTOP;
        const NOCLDWAIT = libc::SA_NOCLDWAIT;
        const SIGINFO = libc::SA_SIGINFO;
        const RESTART = libc::SA_RESTART;
        const NODEFER = libc::SA_NODEFER;
        const RESETHAND = libc::SA_RESETHAND;
        const ONSTACK = libc::SA_ONSTACK;
    }
}

impl Default for SignalConfig {
    fn default() -> Self {
        Self {
            action: SignalAction::Default,
            mask: SignalSet::empty(),
            flags: SignalFlags::RESTART,
        }
    }
}

// ============================================
// SIGNAL MULTIPLEXER
// ============================================

/// Information sur un signal recu
#[derive(Clone, Debug)]
pub struct ReceivedSignal {
    pub signal: c_int,
    pub sender_pid: i32,
    pub sender_uid: u32,
    pub value: Option<i32>,  // Pour RT signals
    pub timestamp: std::time::Instant,
}

/// Queue de signaux temps-reel
pub struct SignalQueue {
    queue: Arc<Mutex<Vec<ReceivedSignal>>>,
    max_size: usize,
}

impl SignalQueue {
    pub fn new(max_size: usize) -> Self {
        Self {
            queue: Arc::new(Mutex::new(Vec::with_capacity(max_size))),
            max_size,
        }
    }

    pub fn push(&self, signal: ReceivedSignal) {
        let mut queue = self.queue.lock().unwrap();
        if queue.len() < self.max_size {
            queue.push(signal);
        }
    }

    pub fn pop(&self) -> Option<ReceivedSignal> {
        let mut queue = self.queue.lock().unwrap();
        if !queue.is_empty() {
            Some(queue.remove(0))
        } else {
            None
        }
    }

    pub fn drain(&self) -> Vec<ReceivedSignal> {
        let mut queue = self.queue.lock().unwrap();
        std::mem::take(&mut *queue)
    }

    pub fn len(&self) -> usize {
        self.queue.lock().unwrap().len()
    }
}

/// Multiplexeur de signaux
pub struct SignalMultiplexer {
    /// Handlers enregistres
    handlers: RwLock<HashMap<c_int, Box<dyn Fn(ReceivedSignal) + Send + Sync>>>,
    /// Queue pour RT signals
    rt_queue: SignalQueue,
    /// Flag pour shutdown gracieux
    shutdown: AtomicBool,
    /// Dernier signal recu (pour handlers simples)
    last_signal: AtomicI32,
}

impl SignalMultiplexer {
    pub fn new() -> Arc<Self> {
        Arc::new(Self {
            handlers: RwLock::new(HashMap::new()),
            rt_queue: SignalQueue::new(256),
            shutdown: AtomicBool::new(false),
            last_signal: AtomicI32::new(0),
        })
    }

    /// Enregistrer un handler
    pub fn register<F>(&self, signal: c_int, handler: F) -> Result<(), std::io::Error>
    where
        F: Fn(ReceivedSignal) + Send + Sync + 'static,
    {
        let mut handlers = self.handlers.write().unwrap();
        handlers.insert(signal, Box::new(handler));

        // Installer le signal handler systeme
        self.install_system_handler(signal)?;

        Ok(())
    }

    /// Desenregistrer un handler
    pub fn unregister(&self, signal: c_int) -> Result<(), std::io::Error> {
        let mut handlers = self.handlers.write().unwrap();
        handlers.remove(&signal);

        // Restaurer le handler par defaut
        unsafe {
            let mut sa: libc::sigaction = std::mem::zeroed();
            sa.sa_sigaction = libc::SIG_DFL;
            libc::sigaction(signal, &sa, std::ptr::null_mut());
        }

        Ok(())
    }

    fn install_system_handler(&self, signal: c_int) -> Result<(), std::io::Error> {
        // Utiliser un handler global qui dispatch vers le multiplexeur
        extern "C" fn handler(sig: c_int, info: *mut libc::siginfo_t, _ctx: *mut c_void) {
            // Dans un vrai code, on utiliserait un global ou thread_local
            // pour acceder au multiplexeur
            // Ici on enregistre juste le signal
            LAST_SIGNAL.store(sig, Ordering::SeqCst);

            if !info.is_null() {
                unsafe {
                    let info = &*info;
                    LAST_SENDER_PID.store(info.si_pid, Ordering::SeqCst);
                    LAST_SENDER_UID.store(info.si_uid as i32, Ordering::SeqCst);
                    LAST_VALUE.store(info.si_value.sival_int, Ordering::SeqCst);
                }
            }
        }

        unsafe {
            let mut sa: libc::sigaction = std::mem::zeroed();
            sa.sa_sigaction = handler as usize;
            sa.sa_flags = libc::SA_SIGINFO | libc::SA_RESTART;
            libc::sigemptyset(&mut sa.sa_mask);

            let ret = libc::sigaction(signal, &sa, std::ptr::null_mut());
            if ret != 0 {
                return Err(std::io::Error::last_os_error());
            }
        }

        Ok(())
    }

    /// Verifier si shutdown demande
    pub fn should_shutdown(&self) -> bool {
        self.shutdown.load(Ordering::SeqCst)
    }

    /// Demander le shutdown
    pub fn request_shutdown(&self) {
        self.shutdown.store(true, Ordering::SeqCst);
    }

    /// Traiter les signaux pending
    pub fn process_pending(&self) {
        let sig = LAST_SIGNAL.swap(0, Ordering::SeqCst);
        if sig != 0 {
            let received = ReceivedSignal {
                signal: sig,
                sender_pid: LAST_SENDER_PID.load(Ordering::SeqCst),
                sender_uid: LAST_SENDER_UID.load(Ordering::SeqCst) as u32,
                value: if Signal::is_realtime(sig) {
                    Some(LAST_VALUE.load(Ordering::SeqCst))
                } else {
                    None
                },
                timestamp: std::time::Instant::now(),
            };

            // Dispatch au handler
            let handlers = self.handlers.read().unwrap();
            if let Some(handler) = handlers.get(&sig) {
                handler(received);
            }
        }
    }
}

// Variables globales pour le handler de signal
static LAST_SIGNAL: AtomicI32 = AtomicI32::new(0);
static LAST_SENDER_PID: AtomicI32 = AtomicI32::new(0);
static LAST_SENDER_UID: AtomicI32 = AtomicI32::new(0);
static LAST_VALUE: AtomicI32 = AtomicI32::new(0);

// ============================================
// ENVOI DE SIGNAUX
// ============================================

/// Envoyer un signal simple
pub fn kill(pid: i32, signal: c_int) -> Result<(), std::io::Error> {
    let ret = unsafe { libc::kill(pid, signal) };
    if ret == 0 {
        Ok(())
    } else {
        Err(std::io::Error::last_os_error())
    }
}

/// Envoyer a un groupe de processus
pub fn killpg(pgrp: i32, signal: c_int) -> Result<(), std::io::Error> {
    let ret = unsafe { libc::killpg(pgrp, signal) };
    if ret == 0 {
        Ok(())
    } else {
        Err(std::io::Error::last_os_error())
    }
}

/// Envoyer un signal RT avec valeur
pub fn sigqueue(pid: i32, signal: c_int, value: i32) -> Result<(), std::io::Error> {
    let val = SigVal { sival_int: value };
    let ret = unsafe {
        libc::sigqueue(pid, signal, std::mem::transmute(val))
    };
    if ret == 0 {
        Ok(())
    } else {
        Err(std::io::Error::last_os_error())
    }
}

/// Envoyer a un thread specifique
#[cfg(target_os = "linux")]
pub fn tgkill(tgid: i32, tid: i32, signal: c_int) -> Result<(), std::io::Error> {
    let ret = unsafe { libc::syscall(libc::SYS_tgkill, tgid, tid, signal) };
    if ret == 0 {
        Ok(())
    } else {
        Err(std::io::Error::last_os_error())
    }
}

// ============================================
// SIGNAL SAFE UTILITIES
// ============================================

/// Flag signal-safe
pub struct SignalFlag(AtomicBool);

impl SignalFlag {
    pub const fn new() -> Self {
        Self(AtomicBool::new(false))
    }

    pub fn set(&self) {
        self.0.store(true, Ordering::SeqCst);
    }

    pub fn clear(&self) {
        self.0.store(false, Ordering::SeqCst);
    }

    pub fn is_set(&self) -> bool {
        self.0.load(Ordering::SeqCst)
    }

    pub fn check_and_clear(&self) -> bool {
        self.0.swap(false, Ordering::SeqCst)
    }
}

// ============================================
// TESTS
// ============================================

#[cfg(test)]
mod tests {
    use super::*;
    use std::process;
    use std::thread;
    use std::time::Duration;

    #[test]
    fn test_signal_set() {
        let mut set = SignalSet::empty();
        assert!(!set.contains(libc::SIGINT));

        set.add(libc::SIGINT);
        assert!(set.contains(libc::SIGINT));

        set.remove(libc::SIGINT);
        assert!(!set.contains(libc::SIGINT));
    }

    #[test]
    fn test_signal_blocking() {
        let mut set = SignalSet::empty();
        set.add(libc::SIGUSR1);

        let old = set.block().unwrap();

        // SIGUSR1 devrait etre bloque maintenant
        // Envoyer a soi-meme
        kill(process::id() as i32, libc::SIGUSR1).unwrap();

        // Verifier qu'il est pending
        let pending = SignalSet::pending().unwrap();
        assert!(pending.contains(libc::SIGUSR1));

        // Restaurer
        old.set_mask().unwrap();
    }

    #[test]
    fn test_rt_signal_range() {
        let min = Signal::sigrtmin();
        let max = Signal::sigrtmax();

        println!("RT signals: {} to {}", min, max);
        assert!(max >= min);
        assert!(Signal::is_realtime(min));
        assert!(Signal::is_realtime(max));
        assert!(!Signal::is_realtime(libc::SIGINT));
    }

    #[test]
    fn test_sigqueue() {
        // Bloquer le signal d'abord
        let mut set = SignalSet::empty();
        let rt_sig = Signal::sigrtmin();
        set.add(rt_sig);
        set.block().unwrap();

        // Envoyer avec valeur
        let test_value = 42;
        sigqueue(process::id() as i32, rt_sig, test_value).unwrap();

        // Verifier qu'il est pending
        let pending = SignalSet::pending().unwrap();
        assert!(pending.contains(rt_sig));

        // Debloquer pour eviter de polluer les autres tests
        set.unblock().unwrap();
    }

    #[test]
    fn test_multiplexer() {
        let mux = SignalMultiplexer::new();
        let received = Arc::new(AtomicBool::new(false));
        let received_clone = received.clone();

        mux.register(libc::SIGUSR2, move |sig| {
            println!("Received signal: {:?}", sig);
            received_clone.store(true, Ordering::SeqCst);
        }).unwrap();

        // Envoyer le signal
        kill(process::id() as i32, libc::SIGUSR2).unwrap();

        // Attendre un peu
        thread::sleep(Duration::from_millis(100));

        // Traiter
        mux.process_pending();

        assert!(received.load(Ordering::SeqCst));
    }
}
```

## Fichiers a rendre
- `src/lib.rs` - Bibliotheque complete
- `src/main.rs` - Demo interactive
- `examples/graceful_shutdown.rs` - Exemple de shutdown propre
- `examples/rt_queue.rs` - Demo des signaux RT

## Criteres d'evaluation
1. **Signal sets (20%)**: sigismember, sigpending correct
2. **SA_SIGINFO (25%)**: Reception des metadonnees
3. **RT signals (25%)**: Queuing, valeurs
4. **Envoi (15%)**: kill, killpg, sigqueue, tgkill
5. **Multiplexeur (15%)**: Architecture propre

## Note qualite: 96/100
- Multi-concepts: 15 concepts couverts
- Safe Rust: Wrappers securises autour des syscalls
- Pedagogique: Separation claire standard vs RT
- Testable: Tests unitaires complets
